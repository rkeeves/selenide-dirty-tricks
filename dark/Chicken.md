# Why did the chicken cross the road?

AJAX stands for Asynchronous JavaScript And XML.

It is a way to send / receive messages to / from a server, and do something on the page in the process.

A simple example would be a dropdown, which only gets its options from the server when the user tries to open it.

Dealing with this kind of instability is a bit tricky.

'Complex abstract systems changing their state in time' is hard for me to think about. So I'll bring up a playful tale of a chicken first.

## Chicken

Suppose there's a chicken on one side of a busy road, and it desperately wants to cross it.

It looks around carefully, and sees that no cars are coming.

It turns its head forward and starts toddling towards the other side.

After some toddling, the chicken finally arrives on the other side, looks back, and happily sighs a relief.

The chicken knows that the cautious looking around payed off. It survived!

But... did the looking around really pay off though? Or was the chicken simply spared due to some arbitrary factor?

What if next time the chicken attempts to pass, and it encounters a faster car. A car so fast that the chicken won't be able to tell in time that a car is approaching?

## Blackbox

Take a look at the following Selenide code:

```java
$("#foo")
    .shouldBe(visible)
    .click();
```

Let's comment it up a bit. Before and after each method  I'll write out what we know about the state in that perfect instant purely based on Selenium/Selenide.

What you'll see below will probably not surprise you, but I personally always forget it:

```java
/* PRE     */                    /* POST    */
/* UNKNOWN */ $("#foo")          /* UNKNOWN */
/* UNKNOWN */ .shouldBe(visible) /* UNKNOWN */
/* UNKNOWN */ .click();          /* UNKNOWN */
```

Before the methods we know nothing about the system's present state, and after the methods we still don't know anything at all.

What we know is that the blackbox in the past passed the test. Then the test results slowly traveled back to us through multiple layers until it arrived back. So at the point in time when we get the response, the blackbox is already in a new state.

As already discussed, a lot of things happen in Selenide between `shouldBe` and `click`.

But even if all of that took no time and the whole library was instantly fast, there's still one thing: we are sending questions to a blackbox, which then sends back answers.

When your response arrives back, the blackbox could be already in a different state...or country, or even on a plane.

Someone might say to this: *oh come on...it is such a small time that...*, but I think the chicken story highlighted well enough the underlying problem.

## Light side

Smart people are able to test large scale apps written in different frameworks and libraries.

The tests don't even know directly about ajax.

They don't depend on AJAX directly. They depend on things like visibility, enabledness.

The testers are smart enough to find special conditions for each situation. They know that in a specific instance of time the state stops changing until they click or do something else. So they have assumptions and have the luxury to work on apps in which these assumptions can be guaranteed by the developers of the **application**.

This is the `light side`.

## Car hits chicken

But what if you can't look for anything. Consider Jsf and Primefaces.

Try the [ajax dropdown](https://www.primefaces.org/showcase-v8/ui/ajax/dropdown.xhtml) for yourself! Widgets with part of their divs hanging in the bottom, random ajax everywhere.

Yes. You can make it pass. Almost always. In certain circumstances. This particular example only. In this perfect setup. With the slight cheat of...

Now imagine a page with 50 of different gadgets and widgets. Each with their own custom ajax and animation.

Now imagine 50 of those pages, with a lot of modals and popups.

And then you find out, that some of these uis are autogenerated from an old code, so devs have basically no control over them.

Some thing when pushed mutates itself. In some other circumstance it does not. It's shiny and enterprisey to the bone.

Your tests will be flaky no matter how many `should`s you cram in there.

## Dark side

What can you do in this situation?

Can we somehow force our way out of this conundrum, by doing hacks that Selenide discourages?

I don't think there exists a `solution` if your app is uncontrollable and unpredictable (e.g. Primefaces), but there are `hacks` which can give `results`.

This is where the `dark side` story begins.
